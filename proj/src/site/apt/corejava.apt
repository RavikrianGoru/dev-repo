 -----
 The APT format: 
 -----
 The Maven Team:
 -----
 -----

Core Java
~~~~~~~~~

--------------------------

http://mrbool.com
http://javahungry.blogspot.com/
http://tutorials.jenkov.com/java-concurrency/benefits.html
https://github.com/sreedharnuli/Learnings
 
 1. Please make sure your env/set uo ready: installed java and set env variables.
 2. Use Note Pad to write java programs as we have to use white board/paper in interview.
 3. JVM 
 
 



--------------------------

* An object has three characteristics:
	state: represents data (value) of an object.
	behavior: represents the behavior (functionality) of an object such as deposit, withdraw etc.
	identity: Object identity is typically implemented via a unique ID. The value of the ID is not visible to the external user. But, it is used internally by the JVM to identify each object uniquely

* The new keyword is used to allocate memory at run time. All objects get memory in Heap memory area.

* Initializing object
	1) by reference: 	s1.rollNo=10; s1.name="ravi";
	2) by method:	 	s1.insertRecord(10,"ravi");
	3) by constructor:	new Student(10,"ravi");
	
	Student
	{
		int rollNo;
		String name;
		insertRecord(int rollNo,String name){}
		Student(){}
		Student(int rollNo,String name){}
	}
* What are the different ways to create an object in Java?
	1) By new keyword
	2) By clone() method
	3) By deserialization
	
	*) By newInstance() method--Class.forName("ClassName").newInstance()----it internally uses new key word.
	*) By factory method etc----it internally uses new key word.
* Actually, 3 ways to create objects.(new keyword, clone() and deserialization).

static keyword:
	variables
	methods
	block
	nested class
* static method can not access non-static data members and methods directly.
* static method can not use this and super keywords.

this keyword usage:
	it refers to current class object.
		this.instanceVarible
		this.instanceMethod()
		method(this)
		Constructor(this)
		this()-->constructor-default
		return this;---> current class obj.

inheritance: one object/class acquires all the properties and behavior of parent object/class.
	code reusability and runtime polymorphism.
	1) IS-A relationship or parent-child relation: a class extends other class
	2) Aggregation or Has-A relation:If a class have an entity reference, it is known as Aggregation.
	3) consist a relation
types:  single
		multilevel
		hierarchical 	
		multiple(with interfaces)
		hybrid(wuth interface)
Method overloading:
	*If a class has multiple methods having same name but different in parameters, it is known as Method Overloading.
	*In java, Method Overloading is not possible by changing the return type of the method only because of ambiguity..
Note: Compile Time Error is better than Run Time Error. So, java compiler renders compiler time error if you declare the same method having same parameters.

Method overriding:
If subclass (child class) has the same method as declared in the parent class, it is known as method overriding in java.
	Method overriding is used to provide specific implementation of a method that is already provided by its super class & used for runtime polymorphism.

super keyword:
	The super keyword in java is a reference variable which is used to refer immediate parent class object.
	Whenever you create the instance of subclass, an instance of parent class is created implicitly which is referred by super reference variable.	
		
	super()----constructor
	super.instanceMethod()
	super.instanceVariable;
* Note: super() is added in each class constructor automatically by compiler if there is no super() or this().

final keyword: 
	variable
	method
	class

Polymorphism in java is a concept by which we can perform a single action by different ways.		
	1) Compile time polymorphism
		If you overload static method in java, it is the example of compile time polymorphism.
	2) Runtime polymorphism(Dynamic Method Dispatch): it is a process in which a call to an overridden method is resolved at runtime rather than compile-time.
		In this process, an overridden method is called through the reference variable of a superclass. 
		The determination of the method to be called is based on the object being referred to by the reference variable.
	* Method is overridden not the datamembers, so runtime polymorphism can't be achieved by data members.		


Static Binding and Dynamic Binding:
	Connecting a method call to the method body is known as binding.
	There are two types of binding
	static binding (also known as early binding): When type of the object is determined at compiled time(by the compiler), it is known as static binding.
		If there is any private, final or static method in a class, there is static binding.
		
	dynamic binding (also known as late binding):	
	
* The java instanceof(type comparison) operator is used to test whether the object is an instance of the specified type (class or subclass or interface).
* When Subclass type refers to the object of Parent class, it is known as downcasting.
* If we perform it directly, compiler gives Compilation error. If you perform it by typecasting, ClassCastException is thrown at runtime. But if we use instanceof operator, downcasting is possible.



Abstraction is a process of hiding the implementation details and showing only functionality to the user.
There are two ways to achieve abstraction in java
	Abstract class (0 to 100%):
		A class that is declared as abstract is known as abstract class.
		It cannot be instantiated.
	Interface (100%)	
* A factory method is the method that returns the instance of the class.
* An abstract class can have data member, abstract method, concrete method, constructor and even main() method.
  An interface in java is a blueprint of a class. It has static constants and abstract methods.
* Java Interface also represents IS-A relationship.
* Multiple inheritance is not supported in case of class because of ambiguity. But it is supported in case of interface because there is no ambiguity as implementation is provided by the implementation class. 

* An interface that have no member is known as marker or tagged interface. 
  For example: Serializable, Cloneable, Remote etc. 
  They are used to provide some essential information to the JVM so that JVM may perform some useful operation.
  if the JVM sees a Class is implementing the Serializable interface it does some special operation on it and writes the state of the object into object stream. 
  This object stream is then available to be read by another JVM. 
  Similarly if JVM finds that a class is implementing Clonnable interface, it performs some special operation in order to support cloning. 
  The same theory goes for RMI and Remote interface.
  With the introduction of annotation in java 5, annotation has become a better choice over maker interface.
  In short a marker interface in Java is used to indicate something to compiler, JVM or any other tool but Annotation is better way of doing same thing.

  Serialization :The serializable interface provides a mechanism of object serialization where an object is represented as a sequence of bytes.
  Deserialization is the process of reading the object from the file and reconstructing the object in the memory.
  Ref: http://mrbool.com/what-is-marker-interface-in-java/28557
  
* Access modifiers in java:
	private-variable,method,constructor
	default
	protected
	public
* Non-Access modifiers in java:
	static
	abstract
	synchronized
	native
	volatile
	transient
	...etc
* If you are overriding any method, overridden method (i.e. declared in subclass) must not be more restrictive.

* Encapsulation in java is a process of wrapping code and data together into a single unit.
	By providing only setter or getter method, you can make the class read-only or write-only. Fully encapsulated class- java bean

	

Mutithreading & Concurrency :http://tutorials.jenkov.com/java-concurrency/benefits.html

  
  
  
  
Java 8- feature:
An interface can have default method and static method.	

