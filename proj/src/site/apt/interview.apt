Sample Interview Questions in Java
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1) How to handle shared resource in mapR jobs?
	Zk for small shared data and DistributedCache for large data.

2) What will happens when you run >java Test?
	1) JVM starts
	2) JVM creates & starts main thread
	3) main thread loads Test.class
	4) Main thread executes public static void main(String... args) of Test calls if available
			if not it will executes main method of its parent class
	5) Unloads Test.class
	6) Terminates Main thread
	7) Shoutdown JVM


3) What are the different ways to create an object in Java?
	1) By new keyword						Employee emp1 = new Employee();
	2) By clone() method					Employee emp4 = (Employee) emp3.clone();
	3) By deserialization					ObjectInputStream in = new ObjectInputStream(new FileInputStream("data.obj"));
											Employee emp5 = (Employee) in.readObject();
	
	*) By newInstance() method				Employee emp2 = (Employee) Class.forName("org.programming.mitra.exercises.Employee").newInstance();
											
											or Employee emp2 = Employee.class.newInstance();
											
											or Constructor<Employee> constructor = Employee.class.getConstructor();
											Employee emp3 = constructor.newInstance();
											
	*) By factory method etc----it internally uses new key word.
	* Actually, 3 ways to create objects.(new keyword, clone() and deserialization).

4) Difference b/w new and netInstance():
	new 
		- operator, used to create object/instance of a class
		- if we know class at begining then it can be used.
		- if no corresponding .class then NoClassDefFoundError at run time.

	newInstance()
		- is a method in Class.class used to create an object/instanct by passing Class name at runtime
		- Object obj = Class.forName("java.lang.String").newInstance();
		- if .class not available at runtime throws ClassNotFoundException

5) Difference between instanceof and isInstsnce:
	instanceof
		- operator, used to check given object is particular type or not.
		- String s = "Ravi"
			if (s instsnceof String || s instanceof Object)
				System.out.print("Hi");
	isInstance:
		- isInstance() method , Available in Class.clss used to check the given object is of particular type or not. Type is available at runtime.

6) Difference between NoClassDefFoundError and ClassNotFoundException

	NoClassDefFoundError
		- Unchecked Exception
		- Test t = new Test(); if Test.class is not available at runtime.
		- Class Name hardcoded in program
	ClassNotFoundException
		- Checked Exception
		- Object obj = Class.forName("Test").netInstance(); if Test.class is not available at runtime.
		- Class Name is passed dynamically

7) Shallow and Deep copy:
	Cloning is a process of creating an exact copy of an existing object in the memory.
	The objects which implement Cloneable interface are only eligible for cloning process.
	
* Shallow Copy:
		The default version of clone() method creates the shallow copy of an object. 
		The shallow copy of an object will have exact copy of all the fields of original object. 

		If original object has any references to other objects as fields, then only references of those objects are copied into clone object, copy of those objects are not created.
		 
		Shallow copy is not 100% disjoint from original object. 
		Shallow copy is not 100% independent of original object.
		Any changes made to clone object will be reflected in original object or vice-versa.
		protected Object clone() throws CloneNotSupportedException
    	{
    	    return super.clone();
    	}

* Deep Copy:
		Deep copy of an object will have exact copy of all the fields of original object just like shallow copy. 
		But in additional, if original object has any references to other objects as fields, then copy of those objects are also created by calling clone() method on them.
		
		That means clone object and original object will be 100% disjoint. 
		They will be 100% independent of each other.
		Any changes made to clone object will not be reflected in original object or vice-versa.
	 

7) Why String is immutable in java?
	1) String pool is possible as String is immutable. it saves a lot of heap memory.
	2) Security threats: if String is not immutable. Socket programming(host and port) and to get DB connection(username and pwd) as Strings. Since String is immutable value can not be changed.
	3) Thread-safety: As String is immutable it can be shared across thread without any synchronization.
	4) String are used in classloaders, no one change the class name as String is immutable.
	5) String is immutable and hashcode is generated at the time of String creation.There is no need to calculate hash code again.
	   String type the best suitable type for key in HashMap.

8) Immutable class and custom immutable class 
  	
  	"An object is considered immutable if its state cannot change after it is constructed".
  	Simply an immutable class is a class whose properties can not be modified after creation.
  	
  	Advantages:
  		1) Immutable classes are great for concurrent applications.(thread-safe)
  		2) More error resistant and secure due to the immutability.
  		
  	Steps to create immtutable class:
  		1) final class : can not be extended.
  		2) Make all fields private and final  
  		3) No setters
  		4) Initialize fields via constructor

9)  ClassLoader Java ClassLoader loads a java class file into java virtual machine.
 	
 	Ref: https://javapapers.com/core-java/java-class-loader/

	1  Bootstrap class loader: Every JVM implements this loader.
		It loads core java API classes from <JAVA_HOME/jre/lib directory>(bootstrap path).
		Bootstrap class loader loads java’s core classes like java.lang, java.util etc.
		
		<This is implemented by native languages like C C++.>
								
	2  Extension class loader: Child of Bootstrap class loader. implemented by java.
		It loads classes form <JAVA_HOME/jre/lib/ext> or any other path specified by <java.ext.dirs> path
		
		JVM implemented extension class loader is <sun.misc.Launcher$ExtClassLoader> class.
								
	3  System/Application class loader:It is child of extension class loader.
		It loads classes from <application path> or any other from environment variable <java.class.path>.
		
		JVM implemented extension class loader is <sun.misc.Launcher$AppClassLoader> class.
	
	We can see more class loaders like java.net.URLClassLoader, java.security.SecureClassLoader etc. Those are all extended from java.lang.ClassLoader

	These class loaders have a hierarchical relationship among them. Class loader can load classes from one level above its hierarchy. 
	First level is bootstrap class loader, second level is extensions class loader and third level is system class loader.	

10) Difference between JDK, JRE, and JVM https://www.javatpoint.com/difference-between-jdk-jre-and-jvm
	
11) JVN architecture/ internals https://www.javatpoint.com/internal-details-of-jvm

12) 


	

